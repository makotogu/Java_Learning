# 创建者模式
创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建和使用分离”
这样可以降低系统的耦合度，使用者不需要关注对象的创建细节

# 单例设计模式
单例模式是Java中最简单的设计模式，这种设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
## 单例设计模式的结构
单例设计模式的主要有以下角色：
* 单例类：只能创建一个实例的类
* 访问类：使用单例类
## 单例模式的实现
> 单例设计模式的分类两种：
>   饿汉式：类加载就会导致该单实例对象被创建    *如果一直不用该对象，也会一直存在于内存中会造成内存的浪费*
>   懒汉式：累加在不会导致该单实例对象被创建，而是首次使用该对象时才会创建
1. 饿汉式-方式1 ： 静态变量方式   
2. 饿汉式-方式2 ： 静态代码块方式
3. 懒汉式-方式1 ： 线程不安全
4. 懒汉式-方式2 ： 线程安全（getInstance方法添加synchronized）
5. 懒汉式-方式3 :  双重通过检查锁 在多线程情况下可能出现空指针异常 解决空指针异常，使用volatile关键字，保证可见性和有序性
6. 懒汉式-方法4 ： 静态内部类方式
7. 饿汉式-方法3 ： 枚举方式
## 存在的问题
### 问题演示
破坏单例模式：
使上面定义的单例类(Singleton)可以创建多个对象，枚举方式除外，有两种方式，分别是序列化和反射
### 问题解决
序列化、反序列化方式破坏单例模式的解决方法
* 再Singleton类中添加readResolve()方法，在反序列时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有就会返回新new出来的对象

# 工厂模式
需求：设计一个咖啡店点餐系统
设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡[AmericanCoffee]和拿铁咖啡[LatteCoffee]);在设计一个咖啡店类(CoffeeStore),咖啡店具有点咖啡的功能
工厂模式最大的优点就是：**解耦**
## 简单工厂模式
简单工厂不是一种设计模式，反而比较像是一种编程习惯。
### 结构
简单工厂包含如下角色：
* 抽象产品：定义了产品的规范，描述了产品的主要特征和功能
* 具体产品：实现或者 继承抽象产品的子类
* 具体工厂：提供了创建产品的方法，调用者通过该方法来创建产品
### 优缺点
**优点**
封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在源代码中修改，这样就降低了客户代码修改的可能性，更容易扩展
**缺点**
增加新产品还是要修改工厂的代码，违背了开闭原则
### 扩展
* **静态工厂**
在开发中也有一部分人将工厂类中创建对象的功能定义为静态的，这就是静态工厂模式，也不是23种设计模式中的
## 工厂方法模式
使用工厂方法模式可以完美解决上述缺点，完全遵循开闭原则
### 概念
定义一个用于创建对象的接口，让子类决定实例化哪个产品对象，工厂方法使一个产品类的实例化延迟到其工厂的子类
### 结构
工厂方法模式的主要角色：
* 抽象工厂(Abstract Factory): 提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品
* 具体工厂(Concrete Factory): 主要是实现抽象工厂中的抽象方法，完成具体产品的创建
* 抽象产品(Product): 定义了产品的规范，描述了产品的主要特性和功能
* 具体产品(Concrete Produckt): 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应
### 优缺点
**优点**
* 用户只需要知道具体工厂的名称就可以得到想要的产品，不需要知道产品的具体创建过程
* 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则
**缺点**
* 每增加一个产品就要增加一个具体的产品类和一个对应具体工厂类，增加了系统的复杂度
## 抽象工厂模式
抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。
### 概念
是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构
抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只产生一个等级的产品，而抽象工厂模式可以生产多个等级的产品
### 结构
抽象工厂模式的主要角色：
* 抽象工厂(Abstract Factory): 提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品
* 具体工厂(Concrete Factory): 主要是实现抽象工厂中的抽象方法，完成具体产品的创建
* 抽象产品(Product): 定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品
* 具体产品(Concrete Produckt): 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一关系
如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类
### 优缺点
**优点**
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只是用同意i个产品族的对象
**缺点**
当产品族中需要增加一个新的产品时，所有工厂类都需要进行修改
### 使用场景
* 当需要创建的对象是一系列相互关联或相互依赖的产品族时
* 系统中有多个产品族，但每次只是用其中的一族产品
* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构

## 模式扩展
**简单工厂+配置文件接触耦合**
可以通过工厂模式+配置文件的方式接触工厂对象和产品对象的耦合，在工厂类中加载配置文件的全类名，并创建对象进行存储（反射），客户端如果需要对象，直接进行获取即可。
