# 创建者模式
创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建和使用分离”
这样可以降低系统的耦合度，使用者不需要关注对象的创建细节

# 单例设计模式
单例模式是Java中最简单的设计模式，这种设计模式属于创建型模式，它提供了一种创建对象的最佳方式。
这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象
## 单例设计模式的结构
单例设计模式的主要有以下角色：
* 单例类：只能创建一个实例的类
* 访问类：使用单例类
## 单例模式的实现
> 单例设计模式的分类两种：
>   饿汉式：类加载就会导致该单实例对象被创建    *如果一直不用该对象，也会一直存在于内存中会造成内存的浪费*
>   懒汉式：累加在不会导致该单实例对象被创建，而是首次使用该对象时才会创建
1. 饿汉式-方式1 ： 静态变量方式   
2. 饿汉式-方式2 ： 静态代码块方式
3. 懒汉式-方式1 ： 线程不安全
4. 懒汉式-方式2 ： 线程安全（getInstance方法添加synchronized）
5. 懒汉式-方式3 :  双重通过检查锁 在多线程情况下可能出现空指针异常 解决空指针异常，使用volatile关键字，保证可见性和有序性
6. 懒汉式-方法4 ： 静态内部类方式
7. 饿汉式-方法3 ： 枚举方式
## 存在的问题
### 问题演示
破坏单例模式：
使上面定义的单例类(Singleton)可以创建多个对象，枚举方式除外，有两种方式，分别是序列化和反射
### 问题解决
序列化、反序列化方式破坏单例模式的解决方法
* 再Singleton类中添加readResolve()方法，在反序列时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有就会返回新new出来的对象

# 工厂模式
需求：设计一个咖啡店点餐系统
设计一个咖啡类(Coffee)，并定义其两个子类(美式咖啡[AmericanCoffee]和拿铁咖啡[LatteCoffee]);在设计一个咖啡店类(CoffeeStore),咖啡店具有点咖啡的功能
工厂模式最大的优点就是：**解耦**
## 简单工厂模式
简单工厂不是一种设计模式，反而比较像是一种编程习惯。
### 结构
简单工厂包含如下角色：
* 抽象产品：定义了产品的规范，描述了产品的主要特征和功能
* 具体产品：实现或者 继承抽象产品的子类
* 具体工厂：提供了创建产品的方法，调用者通过该方法来创建产品
### 优缺点
**优点**
封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在源代码中修改，这样就降低了客户代码修改的可能性，更容易扩展
**缺点**
增加新产品还是要修改工厂的代码，违背了开闭原则
### 扩展
* **静态工厂**
在开发中也有一部分人将工厂类中创建对象的功能定义为静态的，这就是静态工厂模式，也不是23种设计模式中的
## 工厂方法模式
使用工厂方法模式可以完美解决上述缺点，完全遵循开闭原则
### 概念
定义一个用于创建对象的接口，让子类决定实例化哪个产品对象，工厂方法使一个产品类的实例化延迟到其工厂的子类
### 结构
工厂方法模式的主要角色：
* 抽象工厂(Abstract Factory): 提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品
* 具体工厂(Concrete Factory): 主要是实现抽象工厂中的抽象方法，完成具体产品的创建
* 抽象产品(Product): 定义了产品的规范，描述了产品的主要特性和功能
* 具体产品(Concrete Produckt): 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应
### 优缺点
**优点**
* 用户只需要知道具体工厂的名称就可以得到想要的产品，不需要知道产品的具体创建过程
* 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则
**缺点**
* 每增加一个产品就要增加一个具体的产品类和一个对应具体工厂类，增加了系统的复杂度
## 抽象工厂模式
抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族。
### 概念
是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无需指定所要产品的具体类就能得到同族的不同等级的产品的模式结构
抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只产生一个等级的产品，而抽象工厂模式可以生产多个等级的产品
### 结构
抽象工厂模式的主要角色：
* 抽象工厂(Abstract Factory): 提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品
* 具体工厂(Concrete Factory): 主要是实现抽象工厂中的抽象方法，完成具体产品的创建
* 抽象产品(Product): 定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品
* 具体产品(Concrete Produckt): 实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一关系
如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类
### 优缺点
**优点**
当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只是用同意i个产品族的对象
**缺点**
当产品族中需要增加一个新的产品时，所有工厂类都需要进行修改
### 使用场景
* 当需要创建的对象是一系列相互关联或相互依赖的产品族时
* 系统中有多个产品族，但每次只是用其中的一族产品
* 系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构

## 模式扩展
**简单工厂+配置文件接触耦合**
可以通过工厂模式+配置文件的方式接触工厂对象和产品对象的耦合，在工厂类中加载配置文件的全类名，并创建对象进行存储（反射），客户端如果需要对象，直接进行获取即可。

# 原型模式
## 概述
用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象
## 结构
原型模式包含如下角色：
* 抽象原型类：规定了具体原型对象必须实现的clone()方法
* 具体原型类：实现抽象原型类中的clone()方法，他是可以被复制的对象
* 访问类：使用具体原型类中clone()方法来复制新的对象
## 实现
原型模式的克隆分为浅克隆和深克隆
> 浅克隆： 创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性,仍指向原有属性指向的对象的内存地址
> 深克隆： 常见一个对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址
## 使用场景
* 对象的创建非常复杂，可以使用原型模式快捷的创建对象
* 性能和安全的要求比较高
## 扩展（深克隆）
使用序列化反序列化实现深克隆
> 深克隆的类一定要实现Serializable序列化接口否则会报异常

# 建造者模式
## 概述
讲一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。
* 分离了部件的构造(由Builder来负责)和装配(由Director负责)。从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程过于复杂的情况
* 由于实现了构建和装配的解耦，不同的构建器，相同的装配也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦、实现了更好的复用。
* 建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象，用户需要指定复杂对象的类型就可以得到该对象，而无需知道其内部的具体构造细节
## 结构
建造者(Builder)模式包含如下角色：
* 抽象建造者类(Builder): 这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的对象部件的创建
* 具体建造者类(ConcreteBuilder): 实现Builder接口，完成复杂产品的各个部件的创建方式。在构造过程完成后，提供产品的实例
* 产品类(Product): 要创建的复杂对象
* 指挥者类(Director): 调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品信息，只负责保证对象各个部分完成创建或按某种顺序创建
> Director类在建造者模式中拥有很重要的作用，它用于指挥具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合。
>
> 虽然简化了系统结构，但是同时也加重了抽象建造者的指责，也不是太符合单一职责原则，如果construct()过于复杂，建议还是封装到Director中。
## 优缺点
**优点**
* 建造者模式的封装性很好，使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
* 在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
* 可以更加精细地控制产品的创建过程，将复杂产品的创建步骤分解到不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
* 建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试过的代码，因此也就不会对原有功能引入风险，符合开闭原则。
**缺点**
* 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异很大，则不适合使用建造者模式，因此其适用范围收到一定的限制
## 使用范围
建造者模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对比较稳定，所以它通常在以下的场合使用：
* 创建的对象比较复杂，由多个部件组成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的
* 创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的
## 模式扩展
建造者模式除了上面的用途外，开发中还有一个常用的使用方式，当一个类构造器需要传入很多参数时，如果创建这个类的实例，那么代码的可读性会变得很差，而且容易引入错误，此时就可以利用建造者模式进行重构。

# 创建者模式对比
## 工厂方法模式VS建造者模式
工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。
举例：制造手办，工厂方法模式是直接生产一个手办；建造者模式需要组装各个部件，头手脚等，最后产生手办
## 抽象工厂模式VS建造者模式
抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类唯独的产品组合，采用抽象工厂是不需要关心构建过程，只关心数码产品由什么工厂生产即可。
建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品
如果将抽象工厂模式砍成汽车配件生产工厂，生产一个产品族的产品，埃米尔建造者模式就是一个组装工厂，通过对部件的组装可以返回一辆完整的汽车。