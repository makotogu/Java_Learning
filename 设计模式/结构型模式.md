# 结构型模式
结构型模式描述如何将类或对象按照某种布局组成更大的结构，它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或聚合来组合对象。
由于组合关系或聚合关系比继承关系耦合度低，满足合成复用原则，所以对象结构模式比类结构型模式具有更大的灵活性。

# 代理模式
## 概述
由于某些原因需要给某对象提供个代理以控制对象的访问，这时，访问对象不适合活着不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
Java中的代理按照代理类生成时机不同又分为静态代理和动态代理。静态代理代理类在编译期就已经生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK和CGlib两种。
## 结构
代理(Proxy)模式分为三种角色：
* 抽象主题(Subject)类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
* 真实主题(Real Subject)类：实现了抽象主题中的具体业务，是代理对象所表达的真实对象，是最终要引用的对象。
* 代理(Proxy)类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或者扩展真是主题的功能。
## 静态代理
【案例】火车站卖票
如果买火车票，需要去火车站买票，要到火车站，再进行一系列操作。而火车站在多个地方都有代售点，我们去代售点买票就方便很多，火车站是目标对象，代售点是代理对象。
测试类直接访问ProxyPoint对象，也就是ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强。
## JDK动态代理
Java中提供了动态代理Proxy，Proxy不是上述的代理对象的类，而是提供了一个创建对象的静态方法(newProxyInstance方法)获取代理对象

<font color="lightblue">使用了动态代理，我们思考一下的问题</font>

* ProxyFactory是代理类嘛？
  
  * ProxyFactory不是代理模式中的代理类，而代理类是程序在运行过程中动态在内存中生成的类。通过Java开源诊断工具查看代理类的结构。
    > 代理类($Proxy0)实现了SellTickets，这就印证了我们之前说的真实类和代理类实现同样的接口
    > 代理类(Proxy0)将我们提供了的匿名内部类对象传递给了父亲

* 动态代理的执行流程是什么样？
* 执行流程如下：
  1. 在测试类中通过代理对象调用sell()方法
  2. 根据多态的特性，执行的是代理类($Proxy0)中的sell()方法
  3. 代理类($Proxy0)中的sell()方法中又调用了InvocationHandle接口的子实现类对象的invoke方法
  4. invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法

## CGLIB动态代理
同样的上面的案例，使用CGLIB代理实现

如果没有定义SellTIcket接口，指定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。

CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。

CGLIB的jar包坐标：
``` xml
<dependency>
  <groupId>cglib</groupId>
  <artifactId>cglib</artifactId>
  <version>2.2.2</version>
</dependency>
```

## 三种代理的对比
* jdk代理和CGLIB代理
  
  使用CGLIB实现动态代理，CGLIB底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLIB不能对声明为final的类或方法进行代理。

  在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态优化后，在调用次数较少的情况下，JDK代码的效率要高于CGLib代理效率，只有进行大量调用的时候，JDK1.6和1.7比CGlib代理效率低一点，但是到1.8之后JDK代理效率高于CGLIN代理，所以有接口就使用JDK代理
* 动态代理和静态代理
  
  动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理(InvocationHandler.invoke)。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。

  如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法之外，所有代理类也许要实现此方法。增加了代码维护的复杂度，而动态代理就不会出现该问题。

## 优缺点
**优点**
* 代理模式在客户端和目标对象爱之间起到一个中介作用和保护目标对象的作用
* 代理对象可以扩展目标对象的功能
* 代理模式能将客户端和目标对象分离，在一定程度上降低系统的耦合度
**缺点**
* 增加了系统的复杂度

## 使用场景
* **远程（Remote）代理**
* 本地服务通过网络请求远程服务，为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将部分网络通信隐藏起来，指暴露给本地服务一个借口，通过该接口可以访问服务器的功能，而不必关心过多的通信部分的细节。
* **防火墙（Firewall）**
* 当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。
* **保护（Protect or Access）代理**
* 控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限