# 进程与线程
## 进程
* 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至CPU，数据加载内存。在指令运行过程中还需要用到磁盘、网络等设备
* 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程
* 进程可以看作程序的实例，大部分程序可以同时运行多个实例进程，也有的程序只能启动一个实例进程
## 线程
* 一个进程之内可以分为一到多个线程
* 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给CPU执行
* Java中，线程作为最小调度单位，进程作为资源分配的最小单位。在windows中进程是不活动的，只是作为线程的容器
## 二者对比
* 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集
* 进程拥有共享的资源，如内存空间，供器内部的线程共享
* 进程间通信较为复杂
  * 同一台计算机的进程通信成为IPC(Inter-process communication)
  * 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如HTTP
* 线程通信相对简单，因为他们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量
* 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低

# 并行与并发
单核CPU下，线程实际还是串行执行的，操作系统中有一个组件叫做任务调度器，将cpu的时间片（windows下时间片最小约为15毫秒）分给不同的线程使用，只是由于cpu在线时间（时间片很短）的切换非常快，人类感觉是同时运行的。总结为一句话就是：*微观串行，宏观并行*
一般会将这种*线程轮流使用cpu*的做法成为并发：*concurrent* 
* 并发(concurrent) 是同一时间应对(dealing with) 多件事情的能力
* 并行(parallel)是同一时间动手做(doing)多件事情的能力
* 例子
  * 家庭主妇做饭、打扫卫生、给孩子喂奶，她一个人轮流做那么多事请，这就是并发
  * 家庭主妇雇佣了一个保姆，她们一起做这些事，这是既有并发，也有并行
  * 雇了3个保姆，一个专做饭，一个专门打扫卫生，一个喂奶，互不干扰，这就是并行

## 应用之异步调用（案例）
从方法调用角度来讲，如果：
* 需要等待结果返回，才能继续运行就是同步
* 不需要等待结果返回，就能继续运行就是异步
注意：同步在多线程中还有另一层意思，是让多个线程步调一致
1. 设计
   多线程可以让方法执行编程异步的，比如说读取磁盘文件时，假设读取操作花了5秒，如果没有线程调度机制，这五秒调用者什么都做不了，其代码都得暂停
2. 结论
   * 比如在项目中，视频文件需要转换格式等操作比较费时，这时候开启一个新的线程处理视频转换，避免阻塞主线程
   * tomcat的异步servlet也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞tomcat的工作线程
   * ui程序中，开线程进行其他操作，避免阻塞ui线程

## 应用之提高效率（案例）
充分利用多核cpu的优势，提高运行效率。
* 注意使用多核cpu能够提高效率，单核任然是轮流执行
  环境搭建
   * 基准测试工具,使用了比较靠谱的JMH，它会执行程序预热，执行多次测试平均
   * cpu核心数限制，两种思路
     * 使用虚拟机
     * 使用msconfig，分配核心，要重启较麻烦

# Java线程 
## 创建和运行线程
* 方法一，直接使用Thread
``` java
Thread t = new Thread() {
  public void run() {
    //待执行任务
  }
};
t.start();
```
* 方法二，使用Runnable配合Thread
  * 把线程和任务分开
  * Tread表示线程
  * Runnable表示可运行的任务
``` java
Runnable runnable = new Runnable() {
  public void run() {
    // 内容
  }
};
Thread t = new Thread(runnable);
t.start();
```
* Java8以后可以使用lambda表达式精简代码
``` java
Runnable tast2 = () -> log.debug("hello");
```
## 原理Thread和Runnable的关系
* 方法一是把线程和任务合并在一起，方法二是把线程和任务分开了
* 用Runnable更容易与线程池等高级API配合
* 用Runnable让任务类摆脱了Thread继承体系，更灵活

* 方法三，FutureTask配合Thread
FutureTask能几首Callable类型的参数，用来处理有返回结果的情况
``` java
FutureTask<Integer> task3 = new FutureTask<>(() -> {
  log.debug("hello");
  return 100;
})

new Thread(task3, "t3").start();

Integer result = task.get();
log.debug("结果是:{}",result);
```

## 查看进程线程的方法
* windows
  * 任务管理器
  * tasklist
  * taskkill
* linux
  * ps -fe 查看所有进程
  * ps -fT -p \<PID> 
  * kill 杀死进程
  * top 按大写H切换是否显示线程
  * top -H -p \<PID> 
  * top -H -p \<PID> 
## 原理之线程运行
### 栈与栈帧
Java Virtual Machine Stacks(Java虚拟机)
我们都知道JVM中由堆、栈、方法区组成，其中栈内存是给谁用的？其实就是线程，每个线程启动后，虚拟机就会分配一块栈内存
* 每个栈由多个栈帧(Frame)组成，对应着每次方法调用时所占用的内存
* 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法

